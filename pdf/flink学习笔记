http://shiyanjun.cn/archives/1508.html => Apache Flink：特性、概念、组件栈、架构及原理分析
https://zhuanlan.zhihu.com/p/22736103 => Flink源码解析-从API到JobGraph
https://www.jianshu.com/nb/28030243 => 丹之的flink专栏

通过System.out.println(env.getExecutionPlan())获取执行任务json串,通过访问
https://flink.apache.org/visualizer/查看可视化逻辑图

JobManager:
     Job Manager 是 Flink 集群的中控节点，类似于 Apache Storm 的 Nimbus 以及 Apache Spark 的 Driver 的角色。
它负责作业的调度、作业 Jar 包的管理、Checkpoint 的协调和发起、与 Task Manager 之间的心跳检查等工作。


TaskManager
    Task Manager 在 Flink 集群中也是一个个的进程实例，它的数量代表着能够运行作业个数的能力，所有的 Flink 作业最终其实是会在 Task Manager
上运行的，Task Manager 管理着运行在它上面的所有作业的 Task 的整个生命周期，包括了 Task 的启动销毁、内存管理、磁盘 IO、网络传输管理等。
    如果 TaskManager 有四个 Slot，那么它将为每个 Slot 分配 25％ 的内存。 可以在一个 Slot 中运行一个或多个线程。 同一 Slot 中的线程共享相同的 JVM。
同一 JVM 中的任务共享 TCP 连接和心跳消息。TaskManager 的一个 Slot 代表一个可用线程，该线程具有固定的内存，注意 Slot 只对内存隔离，没有对 CPU 隔离。
默认情况下，Flink 允许子任务共享 Slot，即使它们是不同 Task 的 subtask，只要它们来自相同的 Job，这种共享模式可以大大的提高资源利用率。
   Slot 是指 TaskManager 最大能并发执行的能力;parallelism 是指 TaskManager 实际使用的并发能力,如果设置程序的parallelism为1,那么
实际使用的slot只有1个,其他8个solt处于空闲状态

有状态计算以及幂等性
Flink 官网的定义是 Stateful Computations over Data Streams（数据流上的有状态计算），那到底什么是状态呢？举一个无状态计算的例子，比如：
我们只是进行一个字符串拼接，输入 a，输出a_666；输入b，输出 b_666。无状态表示计算输出的结果跟之前的状态没关系，符合幂等性。
幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生副作用。
而计算 PV、UV 就属于有状态计算。实时计算 PV 时，每次都需要从某个存储介质的结果表中拿到之前的 PV 值，+1 后 set 到结果表中。
有状态计算表示输出的结果跟之前的状态有关系，不符合幂等性，访问多次，PV 会增加。





